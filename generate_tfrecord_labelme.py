""" Sample TensorFlow JSON-to-TFRecord converter

usage: generate_tfrecord_labelme.py [-h] [-x XML_DIR] [-l LABELS_PATH] [-o OUTPUT_PATH] [-i IMAGE_DIR] [-c CSV_PATH] [-s SUMMARY_PATH]

optional arguments:
  -h, --help            show this help message and exit
  -j JSON_DIR, --json_dir JSON_DIR
                        Path to the folder where the input .xml files are stored.
  -l LABELS_PATH, --labels_path LABELS_PATH
                        Path to the labels (.pbtxt) file.
  -o OUTPUT_PATH, --output_path OUTPUT_PATH
                        Path of output TFRecord (.record) file.
  -i IMAGE_DIR, --image_dir IMAGE_DIR
                        Path to the folder where the input image files are stored. Defaults to the same directory as XML_DIR.
  -c CSV_PATH, --csv_path CSV_PATH
                        Path of output .csv file. If none provided, then no file will be written.
  -s SUMMARY_PATH, --summary_path SUMMARY_PATH
                        Path of output summary file (.csv). If none provided, then no file will be written.
"""

import os
import glob
import pandas as pd
import io
import json
import argparse

os.environ['TF_CPP_MIN_LOG_LEVEL'] = '2'    # Suppress TensorFlow logging (1)
import tensorflow.compat.v1 as tf
from PIL import Image
from object_detection.utils import dataset_util, label_map_util
from collections import namedtuple

# Initiate argument parser
parser = argparse.ArgumentParser(
    description="Sample TensorFlow JSON-to-TFRecord converter")
parser.add_argument("-j",
                    "--json_dir",
                    help="Path to the folder where the input .json files are stored.",
                    type=str)
parser.add_argument("-l",
                    "--labels_path",
                    help="Path to the labels (.pbtxt) file.", type=str)
parser.add_argument("-o",
                    "--output_path",
                    help="Path of output TFRecord (.record) file.", type=str)
parser.add_argument("-i",
                    "--image_dir",
                    help="Path to the folder where the input image files are stored. "
                         "Defaults to the same directory as JSON_DIR.",
                    type=str, default=None)
parser.add_argument("-c",
                    "--csv_path",
                    help="Path of output .csv file. If none provided, then no file will be "
                         "written.",
                    type=str, default=None)
parser.add_argument("-s",
                    "--summary_path",
                    help="Path of output summary file (.csv). If none provided, then no file will be "
                         "written.",
                    type=str, default=None)

args = parser.parse_args()

# class args:
#     json_dir = "/content/data"
#     labels_path = "/content/label_map_new.pbtxt"
#     output_path = "/content/annot/test.record"
#     image_dir = None
#     csv_path = "/content/annot/example.csv"
#     summary_path = "/content/annot"

if args.image_dir is None:
    args.image_dir = args.json_dir

label_map = label_map_util.load_labelmap(args.labels_path)
label_map_dict = label_map_util.get_label_map_dict(label_map)


def find_bbox(points):
    if len(points) < 2:
        return tuple()

    x1 = x2 = points[0][0]
    y1 = y2 = points[0][1]

    for x, y in points[1:]:
        if x < x1:
            x1 = x
        if y < y1:
            y1 = y

        if x > x2:
            x2 = x
        if y > y2:
            y2 = y

    return ((x1, y1), (x2, y2))


def json_to_csv(path):
    """Iterates through all .json files (generated by labelme) in a given
    directory and combines them in a single Pandas dataframe.

    Parameters:
    ----------
    path : str
        The path containing the .json files
    Returns
    -------
    Pandas DataFrame
        The produced dataframe
    """

    summary = {}
    shape_list = []
    for root, dirs, files in os.walk(path):
        relpath = os.path.relpath(root, path)
        for filename in files:
            if not filename.endswith(".json"):
                continue

            with open(os.path.join(root, filename)) as json_file:
                data = json.loads(json_file.read())

            for shape in data['shapes']: 
                if shape['shape_type'] not in ['rectangle', 'polygon']:
                    continue

                bbox = find_bbox(shape['points'])
                value = (
                    data['imagePath'],
                    os.path.join(relpath, data['imagePath']),
                    data['imageWidth'],
                    data['imageHeight'],
                    shape['label'],
                    int(bbox[0][0]),
                    int(bbox[0][1]),
                    int(bbox[1][0]),
                    int(bbox[1][1]),
                )
                shape_list.append(value)
                try:
                    summary[shape['label']] += 1
                except KeyError:
                    summary[shape['label']] = 1

    json_df = pd.DataFrame(
        shape_list,
        columns=[
            'filename', 'file_path', 'width', 'height', 'class',
            'xmin', 'ymin', 'xmax', 'ymax'
        ]
    )
    summary_df = pd.DataFrame(
        summary.items(),
        columns=['class', 'count']
    )
    return json_df, summary_df


def class_text_to_int(row_label):
    return label_map_dict[row_label]


def split(df, group):
    data = namedtuple('data', ['file_path', 'object'])
    gb = df.groupby(group)
    return [data(file_path, gb.get_group(x)) for file_path, x in zip(gb.groups.keys(), gb.groups)]


def create_tf_example(group, path):
    with tf.gfile.GFile(os.path.join(path, '{}'.format(group.file_path)), 'rb') as fid:
        encoded_jpg = fid.read()
    encoded_jpg_io = io.BytesIO(encoded_jpg)
    image = Image.open(encoded_jpg_io)
    width, height = image.size

    filename = group.file_path.rsplit('/', 1)[-1].encode('utf8')
    image_format = b'jpg'
    xmins = []
    xmaxs = []
    ymins = []
    ymaxs = []
    classes_text = []
    classes = []

    for index, row in group.object.iterrows():
        xmins.append(row['xmin'] / width)
        xmaxs.append(row['xmax'] / width)
        ymins.append(row['ymin'] / height)
        ymaxs.append(row['ymax'] / height)
        classes_text.append(row['class'].encode('utf8'))
        classes.append(class_text_to_int(row['class']))

    tf_example = tf.train.Example(features=tf.train.Features(feature={
        'image/height': dataset_util.int64_feature(height),
        'image/width': dataset_util.int64_feature(width),
        'image/filename': dataset_util.bytes_feature(filename),
        'image/source_id': dataset_util.bytes_feature(filename),
        'image/encoded': dataset_util.bytes_feature(encoded_jpg),
        'image/format': dataset_util.bytes_feature(image_format),
        'image/object/bbox/xmin': dataset_util.float_list_feature(xmins),
        'image/object/bbox/xmax': dataset_util.float_list_feature(xmaxs),
        'image/object/bbox/ymin': dataset_util.float_list_feature(ymins),
        'image/object/bbox/ymax': dataset_util.float_list_feature(ymaxs),
        'image/object/class/text': dataset_util.bytes_list_feature(classes_text),
        'image/object/class/label': dataset_util.int64_list_feature(classes),
    }))
    return tf_example


def main(_):
    writer = tf.python_io.TFRecordWriter(args.output_path)
    path = os.path.join(args.image_dir)
    examples, summary = json_to_csv(args.json_dir)
    grouped = split(examples, 'file_path')
    for group in grouped:
        tf_example = create_tf_example(group, path)
        writer.write(tf_example.SerializeToString())
    writer.close()
    print('Successfully created the TFRecord file: {}'.format(args.output_path))
    if args.csv_path is not None:
        examples.to_csv(args.csv_path, index=None)
        print('Successfully created the CSV file: {}'.format(args.csv_path))
    if args.summary_path is not None:
        summary.to_csv(args.summary_path, index=None)
        print('Successfully created the summary file: {}'.format(args.summary_path))


if __name__ == '__main__':
    tf.app.run()
